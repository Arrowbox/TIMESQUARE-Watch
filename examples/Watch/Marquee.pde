PROGMEM uint8_t marqueeDigits[] = { // 44x6 bitmap
  0x11,0xff,0xff,0x11,0x00,0x00,0xff,0x00,0x11,0xff,0xff,0x11,0x11,0xff,0xff,0x11,
  0xff,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0xff,0xff,0x11,0xff,0xff,0xff,0xff,
  0x11,0xff,0xff,0x11,0x11,0xff,0xff,0x11,0x00,0x00,0x00,0xff,0xff,0x11,0x11,0xff,
  0x00,0xff,0xff,0x00,0xff,0x00,0x00,0xff,0x00,0x00,0x11,0xff,0xff,0x00,0xff,0x00,
  0xff,0x00,0x00,0x00,0xff,0x11,0x00,0x00,0x00,0x00,0x11,0xff,0xff,0x11,0x11,0xff,
  0xff,0x11,0x11,0xff,0xff,0x00,0x11,0xff,0xff,0x00,0x00,0xff,0x00,0x00,0xff,0x00,
  0x00,0x00,0x11,0xff,0x00,0xff,0xff,0x11,0xff,0x00,0xff,0x00,0xff,0xff,0xff,0x11,
  0xff,0xff,0xff,0x11,0x00,0x00,0xff,0x11,0x11,0xff,0xff,0x11,0xff,0x11,0x00,0xff,
  0x00,0x00,0xff,0x11,0xff,0x00,0x00,0xff,0x00,0x00,0xff,0x00,0x11,0xff,0xff,0x11,
  0x00,0x00,0x11,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x11,0xff,0xff,0x00,0x11,0xff,
  0x00,0x11,0xff,0x00,0xff,0x11,0x11,0xff,0x11,0xff,0xff,0xff,0x00,0x11,0xff,0x00,
  0xff,0x11,0x11,0xff,0x00,0x00,0xff,0x00,0xff,0x11,0x00,0x00,0xff,0x11,0x11,0xff,
  0x00,0x00,0xff,0x00,0xff,0x11,0x11,0xff,0xff,0x11,0x11,0xff,0x00,0xff,0x11,0x00,
  0xff,0x11,0x11,0xff,0x00,0x00,0x11,0xff,0xff,0xff,0x11,0x00,0x11,0xff,0xff,0x11,
  0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x11,0xff,0xff,0x11,0x00,0x00,0xff,0x00,
  0x11,0xff,0xff,0x11,0x00,0xff,0xff,0x11,0x00,0xff,0x00,0x00,0x11,0xff,0xff,0x11,
  0x11,0xff,0xff,0x11,0x00,0xff,0x00,0x00 };

#define MARQUEE_SUBMODE_TIME 0
#define MARQUEE_SUBMODE_DATE 1

static int8_t
  marqueeSubmode = MARQUEE_SUBMODE_TIME,
  f              = 0;

void mode_marquee(uint8_t action) {
  DateTime now;
  int      i;


  if(action != ACTION_NONE) {

    // If we just arrived here (whether through mode change
    // or wake from sleep), initialize the matrix driver:
    if(action >= ACTION_HOLD_LEFT) {
      watch.setDisplayMode(7, LED_PLEX_4, true);
      fps   = watch.getFPS();
      depth = 7;
      // And begin in time-display mode:
      marqueeSubmode = MARQUEE_SUBMODE_TIME;
    } else if(action == ACTION_TAP_LEFT) {
      if(++marqueeSubmode > MARQUEE_SUBMODE_DATE)
        marqueeSubmode = MARQUEE_SUBMODE_TIME;
    } else if(action == ACTION_TAP_RIGHT) {
      if(--marqueeSubmode < MARQUEE_SUBMODE_TIME)
        marqueeSubmode = MARQUEE_SUBMODE_DATE;
    }

    // Load time/date digits depending on current submode:
    now = RTC.now();
    if(marqueeSubmode == MARQUEE_SUBMODE_TIME) {
      i = now.hour();
      if((!h24) && (i > 12)) i -= 12;
      loadDigits(i                , DIGIT_HR0);
      loadDigits(now.minute()     , DIGIT_MIN0);
      i = (h24 || (digit[DIGIT_HR0] > 0)) ? 116 : 96;
    } else {
      loadDigits(now.year() - 2000, DIGIT_YEAR0);
      loadDigits(now.month()      , DIGIT_MON0);
      loadDigits(now.day()        , DIGIT_DAY0);
      i = 140;
      if(digit[DIGIT_MON0] > 0) i += 20;
      if(digit[DIGIT_DAY0] > 0) i += 20;
    }

    // Switching modes is awkward if timeout is too
    // close to hold time needed for mode change
    if(i < (fps * 5 / 2)) i = fps * 5 / 2; // 2.5 sec minimum
    // Reset sleep timeout on ANY button action
    watch.setTimeout(i); // Sleep after time/date scrolls off left edge

    curX = 8; // Initialize position off right edge
    f    = 0;
  }

  watch.fillScreen(0);
  i = curX;
  if(marqueeSubmode == MARQUEE_SUBMODE_TIME) {
    if(h24 || (digit[DIGIT_HR0] > 0)) {
      // Leading 0 (if any) is displayed only in 24hr mode
      blit(marqueeDigits, 44, 6, digit[DIGIT_HR0] * 4, 0, i, 1, 4, 6, 255);
      i += 5;
    }
    blit(marqueeDigits, 44, 6, digit[DIGIT_HR1 ] * 4 , 0, i, 1, 4, 6, 255); i += 5;
    blit(marqueeDigits, 44, 6, 40                    , 0, i, 1, 1, 6, 255); i += 2;
    blit(marqueeDigits, 44, 6, digit[DIGIT_MIN0] * 4 , 0, i, 1, 4, 6, 255); i += 5;
    blit(marqueeDigits, 44, 6, digit[DIGIT_MIN1] * 4 , 0, i, 1, 4, 6, 255);
  } else {
    if(digit[DIGIT_MON0] > 0) {
      blit(marqueeDigits, 44, 6, digit[DIGIT_MON0] * 4, 0, i, 1, 4, 6, 255);
      i += 5;
    }
    blit(marqueeDigits, 44, 6, digit[DIGIT_MON1] * 4 , 0, i, 1, 4, 6, 255); i += 5;
    blit(marqueeDigits, 44, 6, 41                    , 0, i, 1, 3, 6, 255); i += 4;
    if(digit[DIGIT_DAY0] > 0) {
      blit(marqueeDigits, 44, 6, digit[DIGIT_DAY0] * 4, 0, i, 1, 4, 6, 255);
      i += 5;
    }
    blit(marqueeDigits, 44, 6, digit[DIGIT_DAY1 ] * 4, 0, i, 1, 4, 6, 255); i += 5;
    blit(marqueeDigits, 44, 6, 41                    , 0, i, 1, 3, 6, 255); i += 4;
    blit(marqueeDigits, 44, 6, digit[DIGIT_YEAR0] * 4, 0, i, 1, 4, 6, 255); i += 5;
    blit(marqueeDigits, 44, 6, digit[DIGIT_YEAR1] * 4, 0, i, 1, 4, 6, 255); i += 5;
  }

  // Every fourth frame, shift text left 1 pixel.  X is not reset or wrapped here...
  // the display timeout will kick in, and X will be set on the next wake operation.
  if(++f >= 4) {
    curX--;
    f = 0;
  }
}

